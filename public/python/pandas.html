
<div class="space-y-4">
  <h1 class="text-2xl font-bold">Pandas Cheat Sheet</h1>

  <div>
    
      class="bg-blue-50 border border-blue-200 rounded-lg p-1"
      href="https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf"
    >
      Official cheat sheet</a
    >
    <p class="text-gray-600">
      Pandas is Python's data manipulation library for working with tabular data.
    </p>
    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mt-3">
      <p class="text-sm">
        <strong>Setup:</strong> All examples assume you have a DataFrame called
        <code class="bg-gray-200 px-1 rounded">df</code> loaded from your data.
      </p>
      <pre class="bg-gray-800 text-white p-2 rounded text-sm mt-2"><span class="text-blue-400">import</span> pandas <span class="text-blue-400">as</span> pd
<span class="text-blue-400">import</span> numpy <span class="text-blue-400">as</span> np

df = pd.read_csv(<span class="text-green-400">'data.csv'</span>)</pre>
    </div>
  </div>

  <!-- Selecting Columns -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Selecting Columns</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># Select specific columns</span>
df[[<span class="text-green-400">'col1'</span>, <span class="text-green-400">'col2'</span>]]

<span class="text-gray-400"># Select single column (returns Series)</span>
df[<span class="text-green-400">'col'</span>]

<span class="text-gray-400"># Select single column (returns DataFrame)</span>
df[[<span class="text-green-400">'col'</span>]]

<span class="text-gray-400"># Rename columns</span>
df.rename(columns={<span class="text-green-400">'old'</span>: <span class="text-green-400">'new'</span>})

<span class="text-gray-400"># Get unique values</span>
df[<span class="text-green-400">'col'</span>].unique()              <span class="text-gray-400"># returns array</span>
df[[<span class="text-green-400">'col'</span>]].drop_duplicates()   <span class="text-gray-400"># returns DataFrame</span></pre>
    </div>
    <div class="bg-yellow-50 rounded p-2 mt-3 text-sm">
      <strong>üí°</strong> Single brackets <code>df['col']</code> ‚Üí Series. Double brackets <code>df[['col']]</code> ‚Üí DataFrame.
    </div>
  </div>

  <!-- Filtering Rows -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Filtering Rows</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># Simple filter</span>
df[df[<span class="text-green-400">'Total'</span>] > 10]

<span class="text-gray-400"># Multiple conditions (AND) - use &</span>
df[(df[<span class="text-green-400">'Total'</span>] > 10) & (df[<span class="text-green-400">'Country'</span>] == <span class="text-green-400">'USA'</span>)]

<span class="text-gray-400"># Multiple conditions (OR) - use |</span>
df[(df[<span class="text-green-400">'Country'</span>] == <span class="text-green-400">'USA'</span>) | (df[<span class="text-green-400">'Country'</span>] == <span class="text-green-400">'Canada'</span>)]

<span class="text-gray-400"># Check if value in list</span>
df[df[<span class="text-green-400">'Country'</span>].isin([<span class="text-green-400">'USA'</span>, <span class="text-green-400">'Canada'</span>])]

<span class="text-gray-400"># Range check</span>
df[df[<span class="text-green-400">'Total'</span>].between(5, 15)]

<span class="text-gray-400"># Pattern matching</span>
df[df[<span class="text-green-400">'Email'</span>].str.contains(<span class="text-green-400">'gmail.com'</span>)]
df[df[<span class="text-green-400">'Name'</span>].str.startswith(<span class="text-green-400">'A'</span>)]

<span class="text-gray-400"># Null checks</span>
df[df[<span class="text-green-400">'Company'</span>].isna()]       <span class="text-gray-400"># is null</span>
df[df[<span class="text-green-400">'Company'</span>].notna()]     <span class="text-gray-400"># is not null</span>

<span class="text-gray-400"># Negation - use ~</span>
df[~df[<span class="text-green-400">'Country'</span>].isin([<span class="text-green-400">'USA'</span>, <span class="text-green-400">'Canada'</span>])]</pre>
    </div>
    <div class="bg-yellow-50 rounded p-2 mt-3 text-sm">
      <strong>üí°</strong> Always wrap each condition in parentheses when combining with <code>&</code> or <code>|</code>. Use <code>&</code> for AND, <code>|</code> for OR, <code>~</code> for NOT.
    </div>
  </div>

  <!-- Sorting & Limiting -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Sorting & Limiting</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># Sort ascending</span>
df.sort_values(<span class="text-green-400">'Total'</span>)

<span class="text-gray-400"># Sort descending</span>
df.sort_values(<span class="text-green-400">'Total'</span>, ascending=<span class="text-blue-400">False</span>)

<span class="text-gray-400"># Sort by multiple columns</span>
df.sort_values([<span class="text-green-400">'Country'</span>, <span class="text-green-400">'Total'</span>], ascending=[<span class="text-blue-400">True</span>, <span class="text-blue-400">False</span>])

<span class="text-gray-400"># Get first/last N rows</span>
df.head(10)
df.tail(10)

<span class="text-gray-400"># Get top/bottom N by value</span>
df.nlargest(10, <span class="text-green-400">'Total'</span>)
df.nsmallest(10, <span class="text-green-400">'Total'</span>)

<span class="text-gray-400"># Slice rows by position</span>
df.iloc[5:15]</pre>
    </div>
    <div class="bg-yellow-50 rounded p-2 mt-3 text-sm">
      <strong>üí°</strong> <code>.nlargest()</code> and <code>.nsmallest()</code> are optimized for "top N" queries.
    </div>
  </div>

  <!-- Aggregation -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Aggregation (groupby)</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># Basic groupby with named aggregations</span>
df.groupby(<span class="text-green-400">'Country'</span>).agg(
    Count=(<span class="text-green-400">'Total'</span>, <span class="text-green-400">'count'</span>),
    TotalSales=(<span class="text-green-400">'Total'</span>, <span class="text-green-400">'sum'</span>),
    AvgSale=(<span class="text-green-400">'Total'</span>, <span class="text-green-400">'mean'</span>)
).reset_index()

<span class="text-gray-400"># Group by multiple columns</span>
df.groupby([<span class="text-green-400">'Country'</span>, <span class="text-green-400">'City'</span>]).agg(
    AvgSale=(<span class="text-green-400">'Total'</span>, <span class="text-green-400">'mean'</span>)
).reset_index()

<span class="text-gray-400"># Quick aggregations</span>
df.groupby(<span class="text-green-400">'Country'</span>)[<span class="text-green-400">'Total'</span>].sum()
df.groupby(<span class="text-green-400">'Country'</span>)[<span class="text-green-400">'Total'</span>].mean()

<span class="text-gray-400"># Multiple aggregations on same column</span>
df.agg({<span class="text-green-400">'Total'</span>: [<span class="text-green-400">'count'</span>, <span class="text-green-400">'sum'</span>, <span class="text-green-400">'mean'</span>, <span class="text-green-400">'min'</span>, <span class="text-green-400">'max'</span>]})</pre>
    </div>
    <div class="bg-yellow-50 rounded p-2 mt-3 text-sm">
      <strong>üí°</strong> <code>.reset_index()</code> converts the grouped result back to a regular DataFrame. Without it, group columns become the index.
    </div>
  </div>

  <!-- Counting Methods -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Counting Methods</h2>
    <p class="text-sm text-gray-600 mb-3">Understanding when to use each is crucial - they behave differently with nulls.</p>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># .size() - counts ALL rows including nulls</span>
df.groupby(<span class="text-green-400">'class'</span>).size()

<span class="text-gray-400"># .count() - counts non-null values per column</span>
df.groupby(<span class="text-green-400">'class'</span>).count()

<span class="text-gray-400"># .nunique() - counts unique values</span>
df.groupby(<span class="text-green-400">'class'</span>)[<span class="text-green-400">'student'</span>].nunique()

<span class="text-gray-400"># .value_counts() - frequency of each value</span>
df[<span class="text-green-400">'Country'</span>].value_counts()
df.groupby(<span class="text-green-400">'class'</span>)[<span class="text-green-400">'score'</span>].value_counts()</pre>
    </div>
    <div class="mt-4 overflow-x-auto">
      <table class="w-full text-sm border border-gray-300">
        <thead class="bg-gray-100">
          <tr>
            <th class="border px-3 py-2 text-left">Method</th>
            <th class="border px-3 py-2 text-left">Question it answers</th>
            <th class="border px-3 py-2 text-left">Counts nulls?</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="border px-3 py-1 font-mono text-xs">.size()</td>
            <td class="border px-3 py-1">How many rows?</td>
            <td class="border px-3 py-1">Yes</td>
          </tr>
          <tr>
            <td class="border px-3 py-1 font-mono text-xs">.count()</td>
            <td class="border px-3 py-1">How many non-null values per column?</td>
            <td class="border px-3 py-1">No</td>
          </tr>
          <tr>
            <td class="border px-3 py-1 font-mono text-xs">.nunique()</td>
            <td class="border px-3 py-1">How many unique values?</td>
            <td class="border px-3 py-1">No</td>
          </tr>
          <tr>
            <td class="border px-3 py-1 font-mono text-xs">.value_counts()</td>
            <td class="border px-3 py-1">How many of each specific value?</td>
            <td class="border px-3 py-1">No</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Filtering Groups -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Filtering Groups</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># Filter after grouping (aggregate first, then filter)</span>
grouped = df.groupby(<span class="text-green-400">'Country'</span>).agg(
    TotalSales=(<span class="text-green-400">'Total'</span>, <span class="text-green-400">'sum'</span>)
).reset_index()
grouped[grouped[<span class="text-green-400">'TotalSales'</span>] > 100]

<span class="text-gray-400"># Filter groups by count</span>
grouped = df.groupby(<span class="text-green-400">'CustomerId'</span>).agg(
    Orders=(<span class="text-green-400">'InvoiceId'</span>, <span class="text-green-400">'count'</span>)
).reset_index()
grouped[grouped[<span class="text-green-400">'Orders'</span>] >= 5]

<span class="text-gray-400"># One-liner with .filter() - returns original rows</span>
df.groupby(<span class="text-green-400">'CustomerId'</span>).filter(<span class="text-blue-400">lambda</span> x: len(x) >= 5)</pre>
    </div>
    <div class="bg-yellow-50 rounded p-2 mt-3 text-sm">
      <strong>üí°</strong> <code>.filter()</code> returns the original rows (not aggregated), while aggregating then filtering returns summary rows.
    </div>
  </div>

  <!-- Transform -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Transform (Group Calculations Back to Rows)</h2>
    <p class="text-sm text-gray-600 mb-3"><code>transform()</code> applies a function to groups but returns results aligned with the original index ‚Äî same shape in, same shape out.</p>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># Add group average to each row</span>
df[<span class="text-green-400">'CountryAvg'</span>] = df.groupby(<span class="text-green-400">'Country'</span>)[<span class="text-green-400">'Total'</span>].transform(<span class="text-green-400">'mean'</span>)

<span class="text-gray-400"># Percent of group total</span>
df[<span class="text-green-400">'PctOfCountry'</span>] = df[<span class="text-green-400">'Total'</span>] / df.groupby(<span class="text-green-400">'Country'</span>)[<span class="text-green-400">'Total'</span>].transform(<span class="text-green-400">'sum'</span>)

<span class="text-gray-400"># Filter: keep only groups with 5+ members</span>
df[df.groupby(<span class="text-green-400">'Country'</span>)[<span class="text-green-400">'Total'</span>].transform(<span class="text-green-400">'count'</span>) >= 5]

<span class="text-gray-400"># Normalize within groups (z-score)</span>
df[<span class="text-green-400">'Normalized'</span>] = df.groupby(<span class="text-green-400">'Country'</span>)[<span class="text-green-400">'Total'</span>].transform(
    <span class="text-blue-400">lambda</span> x: (x - x.mean()) / x.std()
)

<span class="text-gray-400"># Fill NaN with group mean</span>
df[<span class="text-green-400">'Total'</span>] = df.groupby(<span class="text-green-400">'Country'</span>)[<span class="text-green-400">'Total'</span>].transform(
    <span class="text-blue-400">lambda</span> x: x.fillna(x.mean())
)</pre>
    </div>
    <div class="bg-yellow-50 rounded p-2 mt-3 text-sm">
      <strong>üí°</strong> <code>agg()</code> collapses groups into summary rows. <code>transform()</code> broadcasts group results back to every original row.
    </div>
  </div>

  <!-- Binning -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Binning (cut & qcut)</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># cut: Equal-width bins (by value range)</span>
df[<span class="text-green-400">'PriceTier'</span>] = pd.cut(
    df[<span class="text-green-400">'Total'</span>],
    bins=[0, 10, 20, float(<span class="text-green-400">'inf'</span>)],
    labels=[<span class="text-green-400">'Low'</span>, <span class="text-green-400">'Medium'</span>, <span class="text-green-400">'High'</span>]
)

<span class="text-gray-400"># cut: Auto-create n equal-width bins</span>
df[<span class="text-green-400">'PriceTier'</span>] = pd.cut(df[<span class="text-green-400">'Total'</span>], bins=3, labels=[<span class="text-green-400">'Low'</span>, <span class="text-green-400">'Medium'</span>, <span class="text-green-400">'High'</span>])

<span class="text-gray-400"># qcut: Equal-frequency bins (by count)</span>
df[<span class="text-green-400">'Quartile'</span>] = pd.qcut(df[<span class="text-green-400">'Total'</span>], q=4, labels=[<span class="text-green-400">'Q1'</span>, <span class="text-green-400">'Q2'</span>, <span class="text-green-400">'Q3'</span>, <span class="text-green-400">'Q4'</span>])

<span class="text-gray-400"># qcut: Custom percentiles</span>
df[<span class="text-green-400">'Tier'</span>] = pd.qcut(
    df[<span class="text-green-400">'Total'</span>],
    q=[0, 0.25, 0.75, 1],
    labels=[<span class="text-green-400">'Bottom 25%'</span>, <span class="text-green-400">'Middle'</span>, <span class="text-green-400">'Top 25%'</span>]
)</pre>
    </div>
    <div class="mt-4 overflow-x-auto">
      <table class="w-full text-sm border border-gray-300">
        <thead class="bg-gray-100">
          <tr>
            <th class="border px-3 py-2 text-left"></th>
            <th class="border px-3 py-2 text-left">pd.cut()</th>
            <th class="border px-3 py-2 text-left">pd.qcut()</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="border px-3 py-1 font-semibold">Bins by</td>
            <td class="border px-3 py-1">Value range (equal width)</td>
            <td class="border px-3 py-1">Data distribution (equal count)</td>
          </tr>
          <tr>
            <td class="border px-3 py-1 font-semibold">Use when</td>
            <td class="border px-3 py-1">Boundaries matter (age groups, price ranges)</td>
            <td class="border px-3 py-1">Even groups matter (percentiles, quartiles)</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Merging -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Merging DataFrames</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># Inner join (only matching rows)</span>
pd.merge(df1, df2, on=<span class="text-green-400">'key'</span>, how=<span class="text-green-400">'inner'</span>)

<span class="text-gray-400"># Left join (keep all from left)</span>
pd.merge(df1, df2, on=<span class="text-green-400">'key'</span>, how=<span class="text-green-400">'left'</span>)

<span class="text-gray-400"># Right join (keep all from right)</span>
pd.merge(df1, df2, on=<span class="text-green-400">'key'</span>, how=<span class="text-green-400">'right'</span>)

<span class="text-gray-400"># Outer join (keep all from both)</span>
pd.merge(df1, df2, on=<span class="text-green-400">'key'</span>, how=<span class="text-green-400">'outer'</span>)

<span class="text-gray-400"># Multiple join keys</span>
pd.merge(df1, df2, on=[<span class="text-green-400">'key1'</span>, <span class="text-green-400">'key2'</span>])

<span class="text-gray-400"># Different column names</span>
pd.merge(df1, df2, left_on=<span class="text-green-400">'cust_id'</span>, right_on=<span class="text-green-400">'customer_id'</span>)</pre>
    </div>
    <div class="bg-yellow-50 rounded p-2 mt-3 text-sm">
      <strong>üí°</strong> Default is inner join. Use <code>how=</code> to specify: <code>'inner'</code>, <code>'left'</code>, <code>'right'</code>, <code>'outer'</code>.
    </div>
  </div>

  <!-- Concatenating -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Concatenating DataFrames</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># Stack vertically (add rows)</span>
pd.concat([df1, df2])

<span class="text-gray-400"># Stack vertically and remove duplicates</span>
pd.concat([df1, df2]).drop_duplicates()

<span class="text-gray-400"># Stack horizontally (add columns)</span>
pd.concat([df1, df2], axis=1)</pre>
    </div>
  </div>

  <!-- Conditional Logic -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Conditional Logic</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># Simple if/else (2 outcomes)</span>
df[<span class="text-green-400">'Category'</span>] = np.where(df[<span class="text-green-400">'Total'</span>] > 10, <span class="text-green-400">'High'</span>, <span class="text-green-400">'Low'</span>)

<span class="text-gray-400"># Multiple conditions</span>
conditions = [
    df[<span class="text-green-400">'Total'</span>] > 15,
    df[<span class="text-green-400">'Total'</span>] > 5
]
choices = [<span class="text-green-400">'High'</span>, <span class="text-green-400">'Medium'</span>]
df[<span class="text-green-400">'Category'</span>] = np.select(conditions, choices, default=<span class="text-green-400">'Low'</span>)

<span class="text-gray-400"># Alternative: pd.cut() for ranges</span>
df[<span class="text-green-400">'Category'</span>] = pd.cut(
    df[<span class="text-green-400">'Total'</span>],
    bins=[0, 5, 15, float(<span class="text-green-400">'inf'</span>)],
    labels=[<span class="text-green-400">'Low'</span>, <span class="text-green-400">'Medium'</span>, <span class="text-green-400">'High'</span>]
)</pre>
    </div>
    <div class="bg-yellow-50 rounded p-2 mt-3 text-sm">
      <strong>üí°</strong> <code>np.where()</code> for simple if/else. <code>np.select()</code> for multiple conditions. <code>pd.cut()</code> for numeric ranges.
    </div>
  </div>

  <!-- Ranking & Window Functions -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Ranking & Window Functions</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># Row number (unique rank for each row)</span>
df[<span class="text-green-400">'RowNum'</span>] = df[<span class="text-green-400">'Total'</span>].rank(method=<span class="text-green-400">'first'</span>, ascending=<span class="text-blue-400">False</span>).astype(int)

<span class="text-gray-400"># Rank (ties get same rank, gaps after)</span>
df[<span class="text-green-400">'Rank'</span>] = df[<span class="text-green-400">'Total'</span>].rank(method=<span class="text-green-400">'min'</span>, ascending=<span class="text-blue-400">False</span>).astype(int)

<span class="text-gray-400"># Dense rank (ties get same rank, no gaps)</span>
df[<span class="text-green-400">'DenseRank'</span>] = df[<span class="text-green-400">'Total'</span>].rank(method=<span class="text-green-400">'dense'</span>, ascending=<span class="text-blue-400">False</span>).astype(int)

<span class="text-gray-400"># Rank within groups</span>
df[<span class="text-green-400">'CountryRank'</span>] = df.groupby(<span class="text-green-400">'Country'</span>)[<span class="text-green-400">'Total'</span>].rank(
    method=<span class="text-green-400">'first'</span>, ascending=<span class="text-blue-400">False</span>
).astype(int)

<span class="text-gray-400"># Running total</span>
df = df.sort_values(<span class="text-green-400">'Date'</span>)
df[<span class="text-green-400">'RunningTotal'</span>] = df[<span class="text-green-400">'Total'</span>].cumsum()

<span class="text-gray-400"># Previous/Next row values</span>
df[<span class="text-green-400">'PrevTotal'</span>] = df[<span class="text-green-400">'Total'</span>].shift(1)   <span class="text-gray-400"># LAG</span>
df[<span class="text-green-400">'NextTotal'</span>] = df[<span class="text-green-400">'Total'</span>].shift(-1)  <span class="text-gray-400"># LEAD</span></pre>
    </div>
    <div class="bg-yellow-50 rounded p-2 mt-3 text-sm">
      <strong>üí°</strong> <code>method</code> parameter: <code>'first'</code>=row number, <code>'min'</code>=rank, <code>'dense'</code>=dense rank.
    </div>
  </div>

  <!-- Common Operations -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Common Operations</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># Count distinct</span>
df[<span class="text-green-400">'Country'</span>].nunique()

<span class="text-gray-400"># Fill null values</span>
df[<span class="text-green-400">'Company'</span>].fillna(<span class="text-green-400">'N/A'</span>)

<span class="text-gray-400"># String concatenation</span>
df[<span class="text-green-400">'FullName'</span>] = df[<span class="text-green-400">'FirstName'</span>] + <span class="text-green-400">' '</span> + df[<span class="text-green-400">'LastName'</span>]

<span class="text-gray-400"># Date extraction</span>
df[<span class="text-green-400">'Date'</span>] = pd.to_datetime(df[<span class="text-green-400">'Date'</span>])
df[<span class="text-green-400">'Year'</span>] = df[<span class="text-green-400">'Date'</span>].dt.year
df[<span class="text-green-400">'Month'</span>] = df[<span class="text-green-400">'Date'</span>].dt.month

<span class="text-gray-400"># Filter above average</span>
avg = df[<span class="text-green-400">'Total'</span>].mean()
df[df[<span class="text-green-400">'Total'</span>] > avg]

<span class="text-gray-400"># Filter using another DataFrame's values</span>
high_spenders = df[df[<span class="text-green-400">'Total'</span>] > 20][<span class="text-green-400">'CustomerId'</span>]
customers[customers[<span class="text-green-400">'CustomerId'</span>].isin(high_spenders)]</pre>
    </div>
  </div>

  <!-- String Accessor -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">.str Accessor (String Methods)</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># Case conversion</span>
df[<span class="text-green-400">'Name'</span>].str.lower()
df[<span class="text-green-400">'Name'</span>].str.upper()
df[<span class="text-green-400">'Name'</span>].str.title()

<span class="text-gray-400"># Whitespace</span>
df[<span class="text-green-400">'Name'</span>].str.strip()

<span class="text-gray-400"># Search & Match</span>
df[<span class="text-green-400">'Email'</span>].str.contains(<span class="text-green-400">'gmail'</span>)
df[<span class="text-green-400">'Email'</span>].str.startswith(<span class="text-green-400">'a'</span>)
df[<span class="text-green-400">'Email'</span>].str.endswith(<span class="text-green-400">'.com'</span>)

<span class="text-gray-400"># Replace</span>
df[<span class="text-green-400">'Phone'</span>].str.replace(<span class="text-green-400">r'\D'</span>, <span class="text-green-400">''</span>, regex=<span class="text-blue-400">True</span>)  <span class="text-gray-400"># remove non-digits</span>

<span class="text-gray-400"># Split</span>
df[<span class="text-green-400">'Name'</span>].str.split(<span class="text-green-400">' '</span>)                    <span class="text-gray-400"># into list</span>
df[<span class="text-green-400">'Name'</span>].str.split(<span class="text-green-400">' '</span>, expand=<span class="text-blue-400">True</span>)       <span class="text-gray-400"># into columns</span>
df[<span class="text-green-400">'Name'</span>].str.split(<span class="text-green-400">' '</span>).str[0]             <span class="text-gray-400"># first part</span>

<span class="text-gray-400"># Length & Slicing</span>
df[<span class="text-green-400">'Name'</span>].str.len()
df[<span class="text-green-400">'Name'</span>].str[:3]                          <span class="text-gray-400"># first 3 chars</span>

<span class="text-gray-400"># Padding</span>
df[<span class="text-green-400">'ID'</span>].str.zfill(5)                       <span class="text-gray-400"># '42' ‚Üí '00042'</span>

<span class="text-gray-400"># Boolean checks</span>
df[<span class="text-green-400">'Code'</span>].str.isdigit()
df[<span class="text-green-400">'Code'</span>].str.isalpha()</pre>
    </div>
  </div>

  <!-- Datetime Accessor -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">.dt Accessor (Datetime Methods)</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># First, ensure datetime type</span>
df[<span class="text-green-400">'Date'</span>] = pd.to_datetime(df[<span class="text-green-400">'Date'</span>])

<span class="text-gray-400"># Extract components</span>
df[<span class="text-green-400">'Date'</span>].dt.year
df[<span class="text-green-400">'Date'</span>].dt.month
df[<span class="text-green-400">'Date'</span>].dt.day
df[<span class="text-green-400">'Date'</span>].dt.hour
df[<span class="text-green-400">'Date'</span>].dt.dayofweek           <span class="text-gray-400"># 0=Mon, 6=Sun</span>
df[<span class="text-green-400">'Date'</span>].dt.day_name()          <span class="text-gray-400"># 'Monday', etc.</span>
df[<span class="text-green-400">'Date'</span>].dt.quarter             <span class="text-gray-400"># 1-4</span>

<span class="text-gray-400"># Boolean checks</span>
df[<span class="text-green-400">'Date'</span>].dt.is_month_start
df[<span class="text-green-400">'Date'</span>].dt.is_month_end
df[<span class="text-green-400">'Date'</span>].dt.is_weekend          <span class="text-gray-400"># Sat/Sun</span>

<span class="text-gray-400"># Period conversions (for grouping)</span>
df[<span class="text-green-400">'Date'</span>].dt.to_period(<span class="text-green-400">'M'</span>)      <span class="text-gray-400"># monthly</span>
df[<span class="text-green-400">'Date'</span>].dt.to_period(<span class="text-green-400">'Q'</span>)      <span class="text-gray-400"># quarterly</span>

<span class="text-gray-400"># Formatting</span>
df[<span class="text-green-400">'Date'</span>].dt.strftime(<span class="text-green-400">'%Y-%m-%d'</span>)
df[<span class="text-green-400">'Date'</span>].dt.strftime(<span class="text-green-400">'%B %d, %Y'</span>)  <span class="text-gray-400"># 'March 15, 2024'</span></pre>
    </div>
  </div>

  <!-- Categorical Accessor -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">.cat Accessor (Categorical Methods)</h2>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># Convert to categorical</span>
df[<span class="text-green-400">'Size'</span>] = df[<span class="text-green-400">'Size'</span>].astype(<span class="text-green-400">'category'</span>)

<span class="text-gray-400"># Create ordered categorical</span>
df[<span class="text-green-400">'Size'</span>] = pd.Categorical(
    df[<span class="text-green-400">'Size'</span>], 
    categories=[<span class="text-green-400">'S'</span>, <span class="text-green-400">'M'</span>, <span class="text-green-400">'L'</span>, <span class="text-green-400">'XL'</span>], 
    ordered=<span class="text-blue-400">True</span>
)

<span class="text-gray-400"># View categories</span>
df[<span class="text-green-400">'Size'</span>].cat.categories
df[<span class="text-green-400">'Size'</span>].cat.codes              <span class="text-gray-400"># numeric codes (0, 1, 2, 3)</span>

<span class="text-gray-400"># With ordered categorical, comparisons work!</span>
df[df[<span class="text-green-400">'Size'</span>] > <span class="text-green-400">'M'</span>]               <span class="text-gray-400"># rows where Size is L or XL</span></pre>
    </div>
  </div>
  <!-- Apply & Map -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Apply & Map</h2>
    <p class="text-sm text-gray-600 mb-3">Apply custom functions to your data. Use vectorized operations when possible - they're faster.</p>
    <div class="bg-gray-800 text-white p-3 rounded text-sm">
      <pre><span class="text-gray-400"># .map() - Series only, element-wise transformation</span>
df[<span class="text-green-400">'Grade'</span>].map({<span class="text-green-400">'A'</span>: 4, <span class="text-green-400">'B'</span>: 3, <span class="text-green-400">'C'</span>: 2})    <span class="text-gray-400"># dict mapping</span>
df[<span class="text-green-400">'Name'</span>].map(<span class="text-blue-400">lambda</span> x: x.upper())           <span class="text-gray-400"># function</span>
df[<span class="text-green-400">'Code'</span>].map(lookup_series)                   <span class="text-gray-400"># another Series</span>

<span class="text-gray-400"># .apply() on Series - element-wise with more flexibility</span>
df[<span class="text-green-400">'Total'</span>].apply(<span class="text-blue-400">lambda</span> x: x * 1.1)
df[<span class="text-green-400">'Name'</span>].apply(<span class="text-blue-400">lambda</span> x: x.split()[0] <span class="text-blue-400">if</span> <span class="text-green-400">' '</span> <span class="text-blue-400">in</span> x <span class="text-blue-400">else</span> x)

<span class="text-gray-400"># .apply() on DataFrame - apply to each column (default)</span>
df.apply(<span class="text-blue-400">lambda</span> col: col.max() - col.min())    <span class="text-gray-400"># range per column</span>

<span class="text-gray-400"># .apply() on DataFrame - apply to each row</span>
df.apply(<span class="text-blue-400">lambda</span> row: row[<span class="text-green-400">'Price'</span>] * row[<span class="text-green-400">'Qty'</span>], axis=1)

<span class="text-gray-400"># .apply() with custom function</span>
<span class="text-blue-400">def</span> categorize(value):
    <span class="text-blue-400">if</span> value > 100: <span class="text-blue-400">return</span> <span class="text-green-400">'High'</span>
    <span class="text-blue-400">elif</span> value > 50: <span class="text-blue-400">return</span> <span class="text-green-400">'Medium'</span>
    <span class="text-blue-400">else</span>: <span class="text-blue-400">return</span> <span class="text-green-400">'Low'</span>

df[<span class="text-green-400">'Category'</span>] = df[<span class="text-green-400">'Total'</span>].apply(categorize)

<span class="text-gray-400"># .apply() with groupby - apply function to each group</span>
df.groupby(<span class="text-green-400">'Country'</span>).apply(<span class="text-blue-400">lambda</span> g: g.nlargest(3, <span class="text-green-400">'Total'</span>))

<span class="text-gray-400"># .map() on DataFrame - element-wise (replaces deprecated .applymap())</span>
df[[<span class="text-green-400">'A'</span>, <span class="text-green-400">'B'</span>]].map(<span class="text-blue-400">lambda</span> x: f<span class="text-green-400">'${x:.2f}'</span>)      <span class="text-gray-400"># format all cells</span></pre>
    </div>
    <div class="mt-4 overflow-x-auto">
      <table class="w-full text-sm border border-gray-300">
        <thead class="bg-gray-100">
          <tr>
            <th class="border px-3 py-2 text-left">Method</th>
            <th class="border px-3 py-2 text-left">Works on</th>
            <th class="border px-3 py-2 text-left">Use case</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="border px-3 py-1 font-mono text-xs">Series.map()</td>
            <td class="border px-3 py-1">Each element</td>
            <td class="border px-3 py-1">Dict/Series lookup, simple transforms</td>
          </tr>
          <tr>
            <td class="border px-3 py-1 font-mono text-xs">Series.apply()</td>
            <td class="border px-3 py-1">Each element</td>
            <td class="border px-3 py-1">Complex logic, multiple operations</td>
          </tr>
          <tr>
            <td class="border px-3 py-1 font-mono text-xs">DataFrame.apply(axis=0)</td>
            <td class="border px-3 py-1">Each column</td>
            <td class="border px-3 py-1">Column-wise aggregations</td>
          </tr>
          <tr>
            <td class="border px-3 py-1 font-mono text-xs">DataFrame.apply(axis=1)</td>
            <td class="border px-3 py-1">Each row</td>
            <td class="border px-3 py-1">Row-wise calculations using multiple columns</td>
          </tr>
          <tr>
            <td class="border px-3 py-1 font-mono text-xs">DataFrame.map()</td>
            <td class="border px-3 py-1">Each element</td>
            <td class="border px-3 py-1">Format all cells, element-wise transforms</td>
          </tr>
        </tbody>
      </table>
    </div>
    <div class="bg-yellow-50 rounded p-2 mt-3 text-sm">
      <strong>üí°</strong> Prefer vectorized operations (<code>df['col'] * 2</code>) over apply - they're 10-100x faster. Use apply only when vectorization isn't possible.
    </div>
  </div>


  <!-- GeoPandas -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">GeoPandas (Spatial Data)</h2>
    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4">
      <pre class="bg-gray-800 text-white p-2 rounded text-sm"><span class="text-blue-400">import</span> geopandas <span class="text-blue-400">as</span> gpd
<span class="text-blue-400">from</span> shapely.geometry <span class="text-blue-400">import</span> Point

<span class="text-gray-400"># Load spatial data</span>
gdf = gpd.read_file(<span class="text-green-400">'data.geojson'</span>)

<span class="text-gray-400"># Create from DataFrame with coordinates</span>
gdf = gpd.GeoDataFrame(
    df, 
    geometry=gpd.points_from_xy(df[<span class="text-green-400">'lon'</span>], df[<span class="text-green-400">'lat'</span>]),
    crs=<span class="text-green-400">'EPSG:4326'</span>
)</pre>
    </div>
    <div class="bg-gray-800 text-white p-3 rounded text-sm mb-3">
      <pre><span class="text-gray-400"># Spatial filtering</span>
gdf[gdf.within(polygon)]
gdf[gdf.intersects(other_geom)]
gdf[gdf.contains(point)]

<span class="text-gray-400"># Spatial join</span>
joined = gpd.sjoin(points, neighborhoods, predicate=<span class="text-green-400">'within'</span>)

<span class="text-gray-400"># Nearest neighbor join</span>
joined = gpd.sjoin_nearest(points, stations, distance_col=<span class="text-green-400">'dist'</span>)

<span class="text-gray-400"># Geometric operations</span>
gdf[<span class="text-green-400">'buffered'</span>] = gdf.geometry.buffer(100)
gdf[<span class="text-green-400">'centroid'</span>] = gdf.geometry.centroid
gdf[<span class="text-green-400">'distance'</span>] = gdf.geometry.distance(target_point)

<span class="text-gray-400"># Dissolve (merge geometries by group)</span>
dissolved = gdf.dissolve(by=<span class="text-green-400">'region'</span>, aggfunc={<span class="text-green-400">'population'</span>: <span class="text-green-400">'sum'</span>})

<span class="text-gray-400"># Overlay operations</span>
gpd.overlay(gdf1, gdf2, how=<span class="text-green-400">'intersection'</span>)
gpd.overlay(gdf1, gdf2, how=<span class="text-green-400">'difference'</span>)
gpd.overlay(gdf1, gdf2, how=<span class="text-green-400">'union'</span>)

<span class="text-gray-400"># CRS (Coordinate Reference System)</span>
gdf.crs                              <span class="text-gray-400"># check current CRS</span>
gdf = gdf.set_crs(<span class="text-green-400">'EPSG:4326'</span>)       <span class="text-gray-400"># set CRS</span>
gdf = gdf.to_crs(<span class="text-green-400">'EPSG:3857'</span>)        <span class="text-gray-400"># reproject</span>

<span class="text-gray-400"># ‚ö†Ô∏è Always project to meters before calculating area/distance!</span>
gdf_m = gdf.to_crs(<span class="text-green-400">'EPSG:3857'</span>)
gdf[<span class="text-green-400">'area_m2'</span>] = gdf_m.geometry.area

<span class="text-gray-400"># Quick plot</span>
gdf.plot(column=<span class="text-green-400">'population'</span>, cmap=<span class="text-green-400">'viridis'</span>, legend=<span class="text-blue-400">True</span>)
gdf.explore()  <span class="text-gray-400"># interactive map</span></pre>
    </div>
    <div class="bg-yellow-50 rounded p-2 mt-3 text-sm">
      <strong>üí°</strong> Common CRS: <code>EPSG:4326</code> (GPS lat/lon), <code>EPSG:3857</code> (Web Mercator, meters).
    </div>
  </div>

  <!-- Quick Reference -->
  <div class="bg-white rounded-lg border border-gray-200 p-4">
    <h2 class="font-bold text-lg mb-3 text-blue-700">Quick Reference</h2>
    <div class="overflow-x-auto">
      <table class="w-full text-sm border border-gray-300">
        <thead class="bg-gray-100">
          <tr>
            <th class="border px-3 py-2 text-left">Task</th>
            <th class="border px-3 py-2 text-left">Pandas</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="border px-3 py-1">Select columns</td>
            <td class="border px-3 py-1 font-mono text-xs">df[['col1', 'col2']]</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Remove duplicates</td>
            <td class="border px-3 py-1 font-mono text-xs">df.drop_duplicates()</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Filter rows</td>
            <td class="border px-3 py-1 font-mono text-xs">df[df['col'] > value]</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">AND / OR / NOT</td>
            <td class="border px-3 py-1 font-mono text-xs">& / | / ~ (with parentheses)</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Value in list</td>
            <td class="border px-3 py-1 font-mono text-xs">.isin([...])</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Range check</td>
            <td class="border px-3 py-1 font-mono text-xs">.between(a, b)</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Pattern match</td>
            <td class="border px-3 py-1 font-mono text-xs">.str.contains('text')</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Null check</td>
            <td class="border px-3 py-1 font-mono text-xs">.isna() / .notna()</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Sort</td>
            <td class="border px-3 py-1 font-mono text-xs">.sort_values('col', ascending=False)</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">First/Last N</td>
            <td class="border px-3 py-1 font-mono text-xs">.head(n) / .tail(n)</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Group & aggregate</td>
            <td class="border px-3 py-1 font-mono text-xs">.groupby('col').agg(...)</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Count / Sum / Mean</td>
            <td class="border px-3 py-1 font-mono text-xs">.count() / .sum() / .mean()</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Join tables</td>
            <td class="border px-3 py-1 font-mono text-xs">pd.merge(df1, df2, on='key')</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Stack rows</td>
            <td class="border px-3 py-1 font-mono text-xs">pd.concat([df1, df2])</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">If/else</td>
            <td class="border px-3 py-1 font-mono text-xs">np.where(cond, true, false)</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Multiple conditions</td>
            <td class="border px-3 py-1 font-mono text-xs">np.select(conditions, choices)</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Rank</td>
            <td class="border px-3 py-1 font-mono text-xs">.rank(method='first')</td>
          </tr>
          <tr>
            <td class="border px-3 py-1">Previous/Next row</td>
            <td class="border px-3 py-1 font-mono text-xs">.shift(1) / .shift(-1)</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <div class="bg-gray-100 rounded-lg p-4 mt-4">
    <h2 class="font-bold text-lg mb-2">Key Things to Remember</h2>
    <ul class="list-disc ml-5 space-y-1 text-sm">
      <li><strong>Pandas is 0-indexed</strong></li>
      <li><strong>Use <code>&</code> <code>|</code> <code>~</code></strong> for AND, OR, NOT (not the words)</li>
      <li><strong>Always wrap conditions in parentheses</strong> when combining</li>
      <li><strong>Operations return new DataFrames</strong> - assign to save changes</li>
      <li><strong>Use <code>.reset_index()</code></strong> after groupby to get a clean DataFrame</li>
      <li><strong>Chain operations</strong> for readable, fluent code</li>
    </ul>
  </div>
</div>
